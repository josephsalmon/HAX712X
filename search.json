[
  {
    "objectID": "Courses/Visualization/tp.html",
    "href": "Courses/Visualization/tp.html",
    "title": "Data Visualization",
    "section": "",
    "text": "Data visualization is one of the main steps on the way to understanding a dataset. General information on data visualization (beyond Python) can be found in the following list:\n\nA visualization guide from data.europa.eu: The official portal for European data\nThe Python Graph Gallery\nData stories can help provide new ideas for your own work: Maarten Lambrechts’s website\nHow to choose your chart by Andrew V. Abela:\n\n.\nA major difference in the visualization solutions relies on the possibility of performing interactive inspection; otherwise, the solution is said static.\nInteractive tools for data visualization are emerging in Python with plotly, altair, Bokeh, etc. An extensive study by Aarron Geller provides the pros and cons of each method.",
    "crumbs": [
      "Scientific Python",
      "Data Visualization"
    ]
  },
  {
    "objectID": "Courses/Visualization/tp.html#introduction",
    "href": "Courses/Visualization/tp.html#introduction",
    "title": "Data Visualization",
    "section": "",
    "text": "Data visualization is one of the main steps on the way to understanding a dataset. General information on data visualization (beyond Python) can be found in the following list:\n\nA visualization guide from data.europa.eu: The official portal for European data\nThe Python Graph Gallery\nData stories can help provide new ideas for your own work: Maarten Lambrechts’s website\nHow to choose your chart by Andrew V. Abela:\n\n.\nA major difference in the visualization solutions relies on the possibility of performing interactive inspection; otherwise, the solution is said static.\nInteractive tools for data visualization are emerging in Python with plotly, altair, Bokeh, etc. An extensive study by Aarron Geller provides the pros and cons of each method.",
    "crumbs": [
      "Scientific Python",
      "Data Visualization"
    ]
  },
  {
    "objectID": "Courses/Visualization/tp.html#python",
    "href": "Courses/Visualization/tp.html#python",
    "title": "Data Visualization",
    "section": "Python",
    "text": "Python\nThe list is long (and growing) of Python packages for data visualization. We provide some examples in the pandas section of the website, and also in the Scipy course.\n\nGeneric tools\n\nmatplotlib: Visualization with Python\nSource: https://matplotlib.org/.\nThis is the standard library for plots in Python. The documentation is well written and matplotlib should be the default choice for creating static documents (e.g., .pdf or .doc files).\nUsual loading command:\n\nimport matplotlib.pyplot as plt\n\nExample:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nt = np.linspace(0, 2 * np.pi, 1024)\nft1 = np.sin(2 * np.pi * t)\nft2 = np.cos(2 * np.pi * t)\nfig, ax = plt.subplots()\nax.plot(t, ft1, label='sin')\nax.plot(t, ft2, label='cos')\nax.legend(loc='lower right');\n\n\n\n\n\n\nseaborn: statistical data visualization\nSource: https://seaborn.pydata.org/.\nseaborn is built over matplotlib and is specifically tailored for data visualization (maptlotlib is a more flexible and general tool). Default settings are usually nicer than one from maptlotlib, especially for standard tools (histograms, KDE, swarmplots, etc.).\nUsual loading command:\n\nimport seaborn as sns\n\nExample:\n\nimport seaborn as sns\nimport pandas as pd\ndf = pd.DataFrame(dict(sin=ft1, cos=ft2))\nsns.set_style(\"whitegrid\")\nax = sns.lineplot(data=df)\nsns.move_legend(ax, \"lower right\")\nsns.despine()\n\n\n\n\n\n\nplotly: a graphing library for Python\nSource: https://plotly.com/python/.\nThe force of plotly is that it is interactive and can handle R software or julia on top of Python (it relies on Java Script under the hood).\nUsual loading command:\n\nimport plotly\n\nAlternatively, you can also use plotly.express to use predefined figures:\n\nimport plotly.express as px\n\n\nimport plotly.express as px\nfig = px.line(df)\nfig.show()\n\n                                                \n\n\n\n\n\n\n\n\nNote\n\n\n\nIn plotly the figure is interactive. If you click on the legend on the right, you can select a curve to activate/deactivate.\n\n\nBut now you can also create a slider to change a parameter, for instance showing the functions\n\n\\begin{align*}\nf_w: t \\to \\sin(2 \\cdot \\pi \\cdot w \\cdot t)\\\\\ng_w: t \\to \\sin(2 \\cdot \\pi \\cdot w \\cdot t)\n\\end{align*}\n for w \\in [-5, 5]\n\n# inspiration from:\n# https://community.plotly.com/t/multiple-traces-with-a-single-slider-in-plotly/16356\nimport plotly.graph_objects as go\nimport numpy as np\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode()\n\nnum_steps = 101\nslider_range = np.linspace(-5, 5 , num=num_steps)\ntrace_list1 = []\ntrace_list2 = []\n\nfor i, w  in enumerate(slider_range):\n    trace_list1.append(go.Scatter(y=np.sin(2*np.pi*t*w), visible=False, line={'color': 'red'}, name=f\"sin(w * 2 *pi)\"))\n    trace_list2.append(go.Scatter(y=np.cos(2*np.pi*t *w), visible=False, line={'color': 'blue'}, name=f\"cos(w * 2 *pi)\"))\n\nfig = go.Figure(data=trace_list1+trace_list2)\n\n# Initialize display:\nfig.data[51].visible = True\nfig.data[51 + num_steps].visible = True\n\n\nsteps = []\nfor i in range(num_steps):\n    # Hide all traces\n    step = dict(\n        method = 'restyle',\n        args = ['visible', [False] * len(fig.data)],\n        label=f\"{w:.2f}\"\n    )\n    # Enable the two traces we want to see\n    step['args'][1][i] = True\n    step['args'][1][i+num_steps] = True\n\n    # Add step to steps list\n    steps.append(step)\n\nsliders = [dict(\n    active = 50,\n    currentvalue={\"prefix\": \"w = \"},\n    steps = steps,\n)]\n\nfig.layout.sliders = sliders\n\niplot(fig, show_link=False)\n\n                                                \n\n\n\n\n\nInteractive tools\n\nShiny: interactive web applications\nSource: https://shiny.posit.co/py/.\nShiny helps you to customize the layout and style of your application and dynamically respond to events, such as a button press, or dropdown selection. It was born and raised in R, but is now adapted to Python. It can also be interfaced easily with Quarto to render the app on your website, using a {shinylive-python} cell; see an example at https://quarto-ext.github.io/shinylive/.\nThe app created is readable, yet the price to pay is the fluidity of the rendering.\n#| components: [editor, viewer]\n#| folded: true\n#| layout: vertical\n#| standalone: true\n#| viewerHeight: 630\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom shiny import ui, render, App\n\n# Create some random data\nt = np.linspace(0, 2 * np.pi, 1024)\nnum_steps = 101\nslider_range = np.linspace(-5, 5 , num=num_steps)\n\n\napp_ui = ui.page_fixed(\n    ui.h2(\"Playing with sliders\"),\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_slider(\"w\", \"Frequency\", -5, 5, value=1, step=slider_range[-1]-slider_range[-2]),\n        ),\n        ui.panel_main(\n            ui.output_plot(\"plot\")\n        )\n    )\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        ax.plot(t, np.sin(2*np.pi *input.w() * t), label='sin')\n        ax.plot(t, np.cos(2*np.pi *input.w() * t), label='cos')\n        ax.legend(loc='lower right');\n        return fig\n\n\napp = App(app_ui, server)\n\n\n\nbokeh: interactive visualizations in the browsers\nSource: http://bokeh.org/.\nUsual loading command:\n\nimport bokeh\n\nAs of today (Oct. 2023), this is not supported in Quarto, so no example is given here. A server is needed (locally or remotely).\n\n\nvega-altair: declarative visualization in Python\nSource: https://altair-viz.github.io/.\nUsual loading command:\n\nimport altair as alt\n\nAs of today (Oct. 2023), this is not supported in Quarto, so no example is given here. A server is needed (locally or remotely).\n\nAn interesting tutorial: Altair introduction\n\n\n\npygal: python charting\nSource: https://www.pygal.org/.\nWe use it mostly for maps, and especially for the map of France with DOMs. For instance, see the course Creating a Python module, such a map is constructed:\n\n    \n\n\nimport pygal\n\nTo access the French map plugin you need the installation step that follows:\npip install pygal_maps_fr",
    "crumbs": [
      "Scientific Python",
      "Data Visualization"
    ]
  },
  {
    "objectID": "Courses/Visualization/tp.html#animation-display-with-python",
    "href": "Courses/Visualization/tp.html#animation-display-with-python",
    "title": "Data Visualization",
    "section": "Animation display with python",
    "text": "Animation display with python\n\nAnimation with matplotlib\nYou can use FuncAnimation to animate a sequence of images:\n\n%%capture\nfrom matplotlib.animation import FuncAnimation\nfrom IPython.display import HTML, display\nfig, ax = plt.subplots()\nxdata, ydata = [], []\n(ln,) = plt.plot([], [], \"ro\")\n\n\ndef init():\n    ax.set_xlim(0, 2 * np.pi)\n    ax.set_ylim(-1, 1)\n    return (ln,)\n\n\ndef update(frame):\n    xdata.append(frame)\n    ydata.append(np.sin(frame))\n    ln.set_data(xdata, ydata)\n    return (ln,)\n\nani = FuncAnimation(\n    fig,\n    update,\n    interval=50,\n    frames=np.linspace(0, 2 * np.pi, 100),\n    init_func=init,\n    blit=True,\n)\n\ndisplay(HTML(ani.to_jshtml()))\n\n\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\n\nAnother way of displaying video exists, using html5 video:\n\ndisplay(HTML(ani.to_html5_video()))\n\nReferences:\n\nMatplotlib Animations / JavaScript Widgets by Louis Tiao",
    "crumbs": [
      "Scientific Python",
      "Data Visualization"
    ]
  },
  {
    "objectID": "Courses/Visualization/tp.html#animation-with-plotly",
    "href": "Courses/Visualization/tp.html#animation-with-plotly",
    "title": "Data Visualization",
    "section": "Animation with plotly",
    "text": "Animation with plotly\nmatplotlib works fine for advanced tuning, but is harder for simple tasks. So just try plotly for basic animations:\n\nimport plotly.express as px\nfrom plotly.offline import plot\n\ndf = px.data.gapminder()\nfig = px.scatter(\n    df,\n    x=\"gdpPercap\",\n    y=\"lifeExp\",\n    animation_frame=\"year\",\n    animation_group=\"country\",\n    size=\"pop\",\n    color=\"continent\",\n    hover_name=\"country\",\n    log_x=True,\n    size_max=55,\n    range_x=[100, 100000],\n    range_y=[25, 90],\n)\nfig.show(\"notebook\")\n\n                                                \n\n\n\nSpatial visualization\n\nipyleaflet\n\nfrom ipyleaflet import Map, Marker, basemaps, basemap_to_tiles\nMontpellier_gps = (43.610769, 3.876716)\nm = Map(\n  basemaps=basemaps.OpenStreetMap.Mapnik,\n  center=Montpellier_gps,\n  zoom=6\n)\nm.add_layer(Marker(location=Montpellier_gps))\nm\n\n\n\n\n\n\nfolium\n\nimport folium\n\nm = folium.Map(\n    location=Montpellier_gps,\n    control_scale=True,\n    zoom_start=6\n)\n\nfolium.Marker(\n    location=Montpellier_gps,\n    tooltip=\"Click me!\",\n    popup=\"Montpellier\",\n    icon=folium.Icon(icon=\"certificate\", color=\"orange\"),\n).add_to(m)\n\nm\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\nlonboard\nThis is a fast map visualization with Python for large datasets lonboard\n\n\n\n3D visualization\n\nvedo: scientific analysis and visualization of 3D objects\nSource: https://vedo.embl.es/\nThis is a Python module for scientific analysis of 3D objects and point clouds based on VTK (C++) and numpy.",
    "crumbs": [
      "Scientific Python",
      "Data Visualization"
    ]
  },
  {
    "objectID": "Courses/Visualization/tp.html#r-software",
    "href": "Courses/Visualization/tp.html#r-software",
    "title": "Data Visualization",
    "section": "R software",
    "text": "R software\nXXX TODO.",
    "crumbs": [
      "Scientific Python",
      "Data Visualization"
    ]
  },
  {
    "objectID": "Courses/Visualization/tp.html#java-script",
    "href": "Courses/Visualization/tp.html#java-script",
    "title": "Data Visualization",
    "section": "Java Script",
    "text": "Java Script\nXXX TODO. Out of the scope of this course, yet more powerful.\n\nD3JS\n\n\nObservable\nThis is of interest as Quarto can directly read such kinds of figures.\n\nviewof inputs = Inputs.form([\n      Inputs.range([-5, 5], {value: 0.5, step: 0.1, label: tex`\\text{frequency} ~\\omega`}),\n    ])\n\nplt = Plot.plot({\n      color: {\n      legend: true\n    },\n    x: {\n      label: \"x\",\n    //   axis: true\n    },\n    y: {\n    //   axis: true,\n      domain: [-1.2, 1.2]\n    },\n    marks: [\n      Plot.ruleY([0]),\n      Plot.ruleX([0]),\n      Plot.axisX({ y: 0 }),\n      Plot.axisY({ x: 0 }),\n      Plot.line(data, {x: \"x\", y: \"y\", stroke : \"type\", strokeWidth: 2})\n    ]\n  })\n\n\ndata = {\n  const x = d3.range(-10, 10, 0.01);\n  const sins = x.map(x =&gt; ({x: x, y: Math.sin(- x * mu), type: \"sin(w .)\"}));\n  const coss = x.map(x =&gt; ({x: x, y: Math.cos(- x * mu), type: \"cos(w .)\"}));\n  return sins.concat(coss)\n\n}\n\nmu = inputs[0]",
    "crumbs": [
      "Scientific Python",
      "Data Visualization"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HAX712X: Software development for data science",
    "section": "",
    "text": "(Almost) everything you need to know as an applied mathematician/statistician concerning coding and system administration."
  },
  {
    "objectID": "index.html#teachers",
    "href": "index.html#teachers",
    "title": "HAX712X: Software development for data science",
    "section": "Teachers",
    "text": "Teachers\n\nJoseph Salmon: joseph.salmon@umontpellier.fr,\nBenjamin Charlier: benjamin.charlier@umontpellier.fr\n\nThis course material was improved with the help of some students including:\n\nAmelie Vernay\nTanguy Lefort"
  },
  {
    "objectID": "index.html#prerequisite",
    "href": "index.html#prerequisite",
    "title": "HAX712X: Software development for data science",
    "section": "Prerequisite",
    "text": "Prerequisite\nStudents are expected to know basic notions of probabilities, optimization, linear algebra and statistics for this course. Some rudiments in coding are also expected (if, for, while, functions) but not mandatory."
  },
  {
    "objectID": "index.html#course-description",
    "href": "index.html#course-description",
    "title": "HAX712X: Software development for data science",
    "section": "Course description",
    "text": "Course description\nThis course focuses on discovering good coding practices (the language used is Python, but some elements of bash and git will also be useful) for professional coding. A special focus on data processing and visualization will be at the heart of the course. We will mostly focus on basic programming concepts, as well as on discovering the Python scientific libraries, including numpy, scipy, pandas, matplotlib, seaborn. Beyond pandas ninja skills, we will also introduce modern practices for coders: (unitary) tests, version control, documentation generation, etc.\n\n\n\n\nDate\nTeacher\nDetails\n\n\n\n\n11/09/2023\nBC\nCommand-line tools\n\n\n22/09/2023\nBC\nVersion control with Git\n\n\n29/09/2023\nBC\nIDE / Python virtual environment\n\n\n06/10/2023\nBC+JS\nCreating a Python Module, Classes & Exceptions\n\n\n13/10/2023\nJS\nMarkdown to html (Quarto), Unit Tests\n\n\n20/10/2023\nJS\nPandas: Titanic dataset, Pandas: Airparif dataset, Pandas: Bikes dataset\n\n\n27/10/2023\nBC\nContinuous Integration (CI), Generating a documentation (Sphinx), Deploy on Pipy\n\n\n10/11/2023\nJS\nSciPy\n\n\n17/11/2023\nJS\nTime & memory efficiency\n\n\n20/11/2023\nJS\nGraphs\n\n\n15/12/2023\nBC+JS\nThe end: Project presentations"
  },
  {
    "objectID": "index.html#grading",
    "href": "index.html#grading",
    "title": "HAX712X: Software development for data science",
    "section": "Grading",
    "text": "Grading\nFor this course, the grading consists of two projects: one group project (group composition available on Moodle) and a personal one.\nPlease carefully read the projects description page.\n\nBonus\n1 supplementary point on the final grade of the course can be obtained for contributions to improve the course material (practicals, Readme, etc.). See the Bonus section for more details on how to proceed."
  },
  {
    "objectID": "index.html#books-and-other-resources",
    "href": "index.html#books-and-other-resources",
    "title": "HAX712X: Software development for data science",
    "section": "Books and other resources",
    "text": "Books and other resources\nThe resources for the course are available on the present GitHub repository. Additional elementary elements (in French) on Python are available in the course HLMA310 and the associated lecture notes IntroPython.pdf.\n\nMoodle webpage\nThe Moodle web page is available to registered students only.\n\n\nAdditional resources\n\n(General): The Missing Semester of Your CS Education\n(Algorithmic basis): Algorithms, by Jeff Erickson\n(Data Science): Python Data Science Handbook, With Application to Understanding Data by J. Van DerPlas, 2016; videos: Reproducible Data Analysis in Jupyter\n(General) Skiena, The algorithm design manual, 1998\n(General) Courant et al., Informatique pour tous en classes préparatoires aux grandes écoles: Manuel d’algorithmique et programmation structurée avec Python, 2013, (french)\n(General/data science) Guttag, Introduction to Computation and Programming, 2016\n(Code and style) Boswell et Foucher, The Art of Readable Code, 2011\n(Scientific computing tools for Python) Scipy lectures notes\n(Datasets) Open Climate Data"
  },
  {
    "objectID": "Courses/ScipyNumpy/tp.html",
    "href": "Courses/ScipyNumpy/tp.html",
    "title": "SciPy",
    "section": "",
    "text": "Disclaimer: this course is adapted from the notebooks by",
    "crumbs": [
      "Scientific Python",
      "SciPy"
    ]
  },
  {
    "objectID": "Courses/ScipyNumpy/tp.html#introduction",
    "href": "Courses/ScipyNumpy/tp.html#introduction",
    "title": "SciPy",
    "section": "Introduction",
    "text": "Introduction\nSciPy is a scientific library that builds upon NumPy. Among others, SciPy deals with:\n\nIntegration (scipy.integrate)\nOptimization (scipy.optimize)\nInterpolation (scipy.interpolate)\nFourier Transform (scipy.fftpack)\nSignal Processing (scipy.signal)\nLinear Algebra (scipy.linalg)\nSparse matrices (scipy.sparse)\nStatistics (scipy.stats)\nImage processing (scipy.ndimage)\nIO (input/output) (scipy.io)\n\n\n%matplotlib inline\nfrom scipy import linalg\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nfrom IPython.display import HTML, display",
    "crumbs": [
      "Scientific Python",
      "SciPy"
    ]
  },
  {
    "objectID": "Courses/ScipyNumpy/tp.html#animation-display-with-python",
    "href": "Courses/ScipyNumpy/tp.html#animation-display-with-python",
    "title": "SciPy",
    "section": "Animation display with python",
    "text": "Animation display with python\n\nAnimation with matplotlib\nYou can use FuncAnimation to animate a sequence of images:\n\n%%capture\nfig, ax = plt.subplots()\nxdata, ydata = [], []\n(ln,) = plt.plot([], [], \"ro\")\n\n\ndef init():\n    ax.set_xlim(0, 2 * np.pi)\n    ax.set_ylim(-1, 1)\n    return (ln,)\n\n\ndef update(frame):\n    xdata.append(frame)\n    ydata.append(np.sin(frame))\n    ln.set_data(xdata, ydata)\n    return (ln,)\n\nani = FuncAnimation(\n    fig,\n    update,\n    interval=50,\n    frames=np.linspace(0, 2 * np.pi, 100),\n    init_func=init,\n    blit=True,\n)\n\ndisplay(HTML(ani.to_jshtml()))\n\n\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\n\nAnother way of displaying video exists, using html5 video:\n\ndisplay(HTML(ani.to_html5_video()))\n\nReferences:\n\nMatplotlib Animations / JavaScript Widgets by Louis Tiao",
    "crumbs": [
      "Scientific Python",
      "SciPy"
    ]
  },
  {
    "objectID": "Courses/ScipyNumpy/tp.html#animation-with-plotly",
    "href": "Courses/ScipyNumpy/tp.html#animation-with-plotly",
    "title": "SciPy",
    "section": "Animation with plotly",
    "text": "Animation with plotly\nmatplotlib works fine for advanced tuning, but is harder for simple tasks. So just try plotly for basic animations:\n\nimport plotly.express as px\nfrom plotly.offline import plot\n\ndf = px.data.gapminder()\nfig = px.scatter(\n    df,\n    x=\"gdpPercap\",\n    y=\"lifeExp\",\n    animation_frame=\"year\",\n    animation_group=\"country\",\n    size=\"pop\",\n    color=\"continent\",\n    hover_name=\"country\",\n    log_x=True,\n    size_max=55,\n    range_x=[100, 100000],\n    range_y=[25, 90],\n)\nfig.show(\"notebook\")",
    "crumbs": [
      "Scientific Python",
      "SciPy"
    ]
  },
  {
    "objectID": "Courses/ScipyNumpy/tp.html#linear-algebra",
    "href": "Courses/ScipyNumpy/tp.html#linear-algebra",
    "title": "SciPy",
    "section": "Linear algebra",
    "text": "Linear algebra\nscipy for linear algebra : use linalg. It includes functions for solving linear systems, eigenvalues decomposition, SVD, Gaussian elimination (LU, Cholesky), etc.\nReferences:\n\nScipy documentation\n\n\nSolving linear systems:\nFind x such that: A x = b for specified matrix A and vector b.\n\nA = np.array([[1, 0, 3], [4, 5, 12], [7, 8, 9]], dtype=float)\nb = np.array([[1, 2, 3]], dtype=np.float64).T\n\nprint(A, b)\n\nx = linalg.solve(A, b)\nprint(x, x.shape, b.shape)\n\n[[ 1.  0.  3.]\n [ 4.  5. 12.]\n [ 7.  8.  9.]] [[1.]\n [2.]\n [3.]]\n[[ 0.8       ]\n [-0.4       ]\n [ 0.06666667]] (3, 1) (3, 1)\n\n\nCheck the result at a given precision (different from ==)\n\nnp.allclose(A @ x, b, atol=1e-14, rtol=1e-15)\n\nTrue\n\n\nRemark: NEVER (or you should really know why) invert a matrix. ALWAYS solve linear systems instead!\n\nEigenvalues/ Eigenvectors\nA v_n = \\lambda_n v_n with v_n the n-th eigen vector and \\lambda_n the n-th eigen value. The associated python functions are eigvals and eig:\n\nA = np.random.randn(3, 3)\nA = A + A.T\nevals, evecs = linalg.eig(A)\nprint(evals, \"\\n ------\\n\", evecs)\n\nnp.allclose(A, evecs @ np.diag(evals) @ evecs.T)\n\n[ 1.90617361+0.j -2.67944149+0.j -1.03065948+0.j] \n ------\n [[ 0.97703153  0.12813191 -0.17026918]\n [ 0.02262339 -0.85688486 -0.51501118]\n [ 0.21189045 -0.4993301   0.84010231]]\n\n\nTrue\n\n\n\n\n\n\n\n\nEXERCISE: Eigenvalues/Eigenvectors\n\n\n\nVerify numerically that the outputs from linalg.eig are indeed approximately eigenvalues and eigenvectors of matrix A above.\nHint: use Scipy documentation on allclose\n\n\n\n\nSymmetric matrices\nIf A is symmetric you should use eigvalsh (H for Hermitian) instead: This is more robust and leverages the structures (you know they are real!)\n\n\n\nMatrix operations\n\nlinalg.trace(A) # trace\nlinalg.det(A) # determinant\nlinalg.inv(A) # Inverse, consider NEVER using it though :)\n\n\n\nNorms\n\nprint(linalg.norm(A, ord=\"fro\"))  # fro for Frobenius\nprint((np.sum(A ** 2)) ** 0.5)\nprint(linalg.norm(A, ord=2))\nprint((linalg.eigvalsh(A.T @ A) ** 0.5))\nprint(linalg.norm(A, ord=np.inf))\n\n3.446035910589746\n3.4460359105897456\n2.679441492897133\n[1.03065948 1.90617361 2.67944149]\n3.1771027147968516\n\n\n\n\n\n\n\n\nEXERCISE: Norms computation\n\n\n\nCheck numerically what the instruction linalg.norm(A, ord=np.inf) is computing. Double check with the help and a numerical test.\n\n\n\nA = np.random.randn(3, 3)\nprint(linalg.norm(A, ord=np.inf))\n\n5.331333633432739",
    "crumbs": [
      "Scientific Python",
      "SciPy"
    ]
  },
  {
    "objectID": "Courses/ScipyNumpy/tp.html#random-generation-distributions-etc.",
    "href": "Courses/ScipyNumpy/tp.html#random-generation-distributions-etc.",
    "title": "SciPy",
    "section": "Random generation, distributions, etc.",
    "text": "Random generation, distributions, etc.\nReferences:\n\nGood practices with numpy random number generators by Albert Thomas\nNumpy documentation on RandomState\nRandom Widgets, by Joseph Salmon: Visualization of various popular distributions.\n\n\nseed = 12345\nrng = np.random.default_rng(seed)  # can be called without a seed\nrng.random()\n\n0.22733602246716966",
    "crumbs": [
      "Scientific Python",
      "SciPy"
    ]
  },
  {
    "objectID": "Courses/ScipyNumpy/tp.html#optimization",
    "href": "Courses/ScipyNumpy/tp.html#optimization",
    "title": "SciPy",
    "section": "Optimization",
    "text": "Optimization\nGoal: find functions minima or maxima\nReferences:\n\nScipy Lectures on mathematical optimization.\n\n\nfrom scipy import optimize\n\n\nFinding (local!) minima\ndef f(x):\n    return 4 * x ** 3 + (x - 2) ** 2 + x ** 4\n\n\ndef mf(x):\n    return -(4 * x ** 3 + (x - 2) ** 2 + x ** 4)\n\n\nxs = np.linspace(-5, 3, 100)\nplt.figure()\nplt.plot(xs, f(xs))\nplt.show()\n\n\n\n\n\n\n\nDefault solver for minimization/maximization: fmin_bfgs (see Wikipedia on BFGS)\nx_min = optimize.fmin_bfgs(f, x0=-4)\nx_max = optimize.fmin_bfgs(mf, x0=-2)\nx_min2 = optimize.fmin_bfgs(f, x0=2)\n\n\nplt.figure()\nplt.plot(xs, f(xs))\nplt.plot(x_min, f(x_min), \"o\", markersize=10, color=\"orange\")\nplt.plot(x_min2, f(x_min2), \"o\", markersize=10, color=\"red\")\nplt.plot(x_max, f(x_max), \"|\", markersize=20)\nplt.show()\n\n\n\nOptimization terminated successfully.\n         Current function value: -3.506641\n         Iterations: 7\n         Function evaluations: 16\n         Gradient evaluations: 8\nOptimization terminated successfully.\n         Current function value: -6.201654\n         Iterations: 5\n         Function evaluations: 12\n         Gradient evaluations: 6\nOptimization terminated successfully.\n         Current function value: 2.804988\n         Iterations: 7\n         Function evaluations: 16\n         Gradient evaluations: 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEXERCISE: Basin of attraction\n\n\n\nDraw the points on the curves with two different colors :\n\norange: for the points leading to find the left local minima\nred: for the points leading to the right local minima.\n\n\n\n\n\nFind the zeros of a function\nFind x such that f(x) = 0, with fsolve.\nomega_c = 3.0\n\ndef f(omega):\n    return np.tan(2 * np.pi * omega) - omega_c / omega\n\n\nx = np.linspace(1e-8, 3.2, 1000)\ny = f(x)\n\n# Remove vertical lines when the function flips signs\nmask = np.where(np.abs(y) &gt; 50)\nx[mask] = y[mask] = np.nan\nplt.plot(x, y)\nplt.plot([0, 3.3], [0, 0], \"k\")\nplt.ylim(-5, 5)\n\noptimize.fsolve(f, 0.72)\noptimize.fsolve(f, 1.1)\noptimize.fsolve(f, np.linspace(0.001, 3, 20))\nnp.unique(np.round(optimize.fsolve(f, np.linspace(0.2, 3, 20)), 3))\n\nmy_zeros = (\n    np.unique((optimize.fsolve(f, np.linspace(0.2, 3, 20)) * 1000).astype(int)) / 1000.0\n)\nplt.figure()\nplt.plot(x, y, label=\"$f$\")\nplt.plot([0, 3.3], [0, 0], \"k\")\nplt.plot(my_zeros, np.zeros(my_zeros.shape), \"o\", label=\"$x : f(x)=0$\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParameters estimation\nfrom scipy.optimize import curve_fit\n\n\ndef f(x, a, b, c):\n    \"\"\"f(x) = a exp(-bx) + c.\"\"\"\n    return a * np.exp(-b * x) + c\n\n\nx = np.linspace(0, 4, 50)\ny = f(x, 2.5, 1.3, 0.5)  # true signal\nyn = y + 0.2 * np.random.randn(len(x))  # noisy added\n\nplt.figure()\nplt.plot(x, yn, \".\")\nplt.plot(x, y, \"k\", label=\"$f$\")\nplt.legend()\nplt.show()\n\n(a, b, c), _ = curve_fit(f, x, yn)\nprint(a,\"\\n\", b,\"\\n\", c)\n\n\n\n\n\n\n\n\n2.426329678019792 \n 1.519605907932409 \n 0.5533989761688228\n\n\n\nDisplaying\nplt.figure()\nplt.plot(x, yn, \".\", label=\"data\")\nplt.plot(x, y, \"k\", label=\"True $f$\")\nplt.plot(x, f(x, a, b, c), \"--k\", label=\"Estimated $\\hat{f}$\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\nFor polynomial fitting, one can directly use numpy functionsL\nx = np.linspace(0, 1, 10)\ny = np.sin(x * np.pi / 2.0)\nline = np.polyfit(x, y, deg=10)\nplt.figure()\nplt.plot(x, y, \".\", label=\"data\")\nplt.plot(x, np.polyval(line, x), \"k--\", label=\"polynomial approximation\")\nplt.legend()\nplt.show()\n\n/home/jsalmon/anaconda3/envs/peerannot/lib/python3.10/site-packages/IPython/core/interactiveshell.py:3548: RankWarning:\n\nPolyfit may be poorly conditioned",
    "crumbs": [
      "Scientific Python",
      "SciPy"
    ]
  },
  {
    "objectID": "Courses/ScipyNumpy/tp.html#interpolation",
    "href": "Courses/ScipyNumpy/tp.html#interpolation",
    "title": "SciPy",
    "section": "Interpolation",
    "text": "Interpolation\nfrom scipy.interpolate import interp1d, CubicSpline\n\n\ndef f(x):\n    return np.sin(x)\n\n\nn = np.arange(0, 10)\nx = np.linspace(0, 9, 100)\n\ny_meas = f(n) + 0.1 * np.random.randn(len(n))  # add noise\ny_real = f(x)\n\nlinear_interpolation = interp1d(n, y_meas)\ny_interp1 = linear_interpolation(x)\n\ncubic_interpolation = CubicSpline(n, y_meas)\ny_interp2 = cubic_interpolation(x)\n\n\nplt.figure()\nplt.plot(n, y_meas, \"bs\", label=\"noisy data\")\nplt.plot(x, y_real, \"k\", lw=2, label=\"true function\")\nplt.plot(x, y_interp1, \"r\", label=\"linear interp\")\nplt.plot(x, y_interp2, \"g\", label=\"CubicSpline interp\")\nplt.legend(loc=3)\nplt.show()",
    "crumbs": [
      "Scientific Python",
      "SciPy"
    ]
  },
  {
    "objectID": "Courses/ScipyNumpy/tp.html#images",
    "href": "Courses/ScipyNumpy/tp.html#images",
    "title": "SciPy",
    "section": "Images",
    "text": "Images\n\nRGB decomposition\nFirst, discuss the color decomposition in RGB. The RGB color model is an additive color model[1] in which the red, green and blue primary colors of light are added together in various ways to reproduce a broad array of colors. Hence, each channel (R, G or B) represents a grayscale image, usually coded on [0,1] or [0,255].\nfrom scipy import ndimage, datasets\n\nimg = datasets.face()\nprint(type(img), img.dtype, img.ndim, img.shape)\n\nprint(2 ** 8)  # uint8-&gt; code sur 256 niveau.\n\nn_1, n_2, n_3 = img.shape\nprint(n_1, n_2, n_3)\n\n# True image\nplt.figure()\nplt.imshow(img)\nplt.axis(\"off\")\nplt.show()\n\n\n\n&lt;class 'numpy.ndarray'&gt; uint8 3 (768, 1024, 3)\n256\n768 1024 3\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots(3, 2)\nfig.set_size_inches(7, 4.5)\nn_1, n_2, n_3 = img.shape\n\n# add subplot titles\nax[0, 0].set_title(\"Red channel\")\nax[0, 0].imshow(img[:, :, 0], cmap=plt.cm.Reds)\nax[0, 1].set_title(\"Pixel values histogram (red channel)\")\nax[0, 1].hist(img[:, :, 0].reshape(n_1 * n_2), np.arange(0, 256))\n\nax[1, 0].set_title(\"Green channel\")\nax[1, 0].imshow(img[:, :, 1], cmap=plt.cm.Greens)\nax[1, 1].set_title(\"Pixel values histogram (green channel)\")\nax[1, 1].hist(img[:, :, 1].reshape(n_1 * n_2), np.arange(0, 256))\n\nax[2, 0].set_title(\"Blue channel\")\nax[2, 0].imshow(img[:, :, 2], cmap=plt.cm.Blues)\nax[2, 1].set_title(\"Pixel values histogram (blue channel)\")\nax[2, 1].hist(img[:, :, 2].reshape(n_1 * n_2), np.arange(0, 256))\n\nplt.tight_layout()\n\n\n\n\n\n\n\nprint(img.flags)  # cannot edit...\nimg_compressed = img.copy()\nimg_compressed.setflags(write=1)\nprint(img_compressed.flags)  # can edit now\n\n\nimg_compressed[img_compressed &lt; 70] = 50\nimg_compressed[(img_compressed &gt;= 70) & (img_compressed &lt; 110)] = 100\nimg_compressed[(img_compressed &gt;= 110) & (img_compressed &lt; 180)] = 150\nimg_compressed[(img_compressed &gt;= 180)] = 200\nplt.figure()\nplt.imshow(img_compressed, cmap=plt.cm.gray)\nplt.axis(\"off\")\nplt.show()\n\n\n\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : False\n  WRITEABLE : False\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n\n\n\n\n\n\n\n\n\n\n\nConvert a color image in grayscale\nplt.figure()\nplt.imshow(np.mean(img, axis=2), cmap=plt.cm.gray)\nplt.show()\n\n\n\n\n\n\n\n\n\nChanging colors in an image\nimport pooch\nimport os\n\nurl = \"https://upload.wikimedia.org/wikipedia/en/thumb/0/05/Flag_of_Brazil.svg/486px-Flag_of_Brazil.svg.png\"\nname_img =pooch.retrieve(url, known_hash=None)\n\nimg = (255 * plt.imread(name_img)).astype(int)\nimg = img.copy()\nplt.figure()\nplt.imshow(img)\n\nfig, ax = plt.subplots(3, 2)\nfig.set_size_inches(7, 4.5)\nn_1, n_2, n_3 = img.shape\n\nax[0, 0].imshow(img[:, :, 0], cmap=plt.cm.Reds)\nax[0, 0].set_title(\"Red channel\")\nax[0, 1].hist(img[:, :, 0].reshape(n_1 * n_2), np.arange(0, 256), density=True)\nax[0, 1].set_title(\"Pixel values histogram (red channel)\")\n\nax[1, 0].imshow(img[:, :, 1], cmap=plt.cm.Greens)\nax[1, 0].set_title(\"Green channel\")\nax[1, 1].hist(img[:, :, 1].reshape(n_1 * n_2), np.arange(0, 256), density=True)\nax[1, 1].set_title(\"Pixel values histogram (green channel)\")\n\nax[2, 0].imshow(img[:, :, 2], cmap=plt.cm.Blues)\nax[2, 0].set_title(\"Blue channel\")\nax[2, 1].hist(img[:, :, 2].reshape(n_1 * n_2), np.arange(0, 256), density=True)\nax[2, 1].set_title(\"Pixel values histogram (Blue channel)\")\nplt.tight_layout()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEXERCISE: Make the Brazilian italianer\n\n\n\nCreate a version of the Brazilian flag as follows:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRGBA\nRGBA stands for red (R), green (G), blue (B) and alpha (A). Alpha indicates how the transparency allows an image to be combined over others using alpha compositing, with transparent areas.\n\n\nHexadecimal decomposition\nOften, colors are represented not with an RGB triplet, say (255, 0, 0), but with a hexadecimal code (say #FF0000). To get a hexadecimal decomposition, transform each 8-bit RGB channel (i.e., 2^8=256) into a 2-digit hexadecimal number (i.e., 16^2=256). This requires letters for representing 10: A, 11: B,\\dots, 15: FF (see https://www.rgbtohex.net/ for an online converter)\n\n\nCMYK decomposition\nThis is rather a subtractive color model, where the primary colors are cyan (C), magenta (M), yellow (Y), and black (B). For a good source to go from RGB to CMYK (and back), see https://fr.wikipedia.org/wiki/Quadrichromie.\n\n\nHSL (hue, saturation, lightness)\nXXX TODO.\nHere, you can find a simple online converter for all popular color models: https://www.myfixguide.com/color-converter/.",
    "crumbs": [
      "Scientific Python",
      "SciPy"
    ]
  },
  {
    "objectID": "Courses/ScipyNumpy/tp.html#image-files-formats",
    "href": "Courses/ScipyNumpy/tp.html#image-files-formats",
    "title": "SciPy",
    "section": "Image files formats",
    "text": "Image files formats\nBitmap formats: - PNG (raw, uncompressed format, opens with Gimp) - JPG (compressed format) - GIF (compressed, animated format)\nVector formats: - PDF (recommended for your documents) - SVG (easily modifiable with Inkscape) - EPS - etc.\nx1 = np.linspace(0.0, 5.0, num=50)\nx2 = np.linspace(0.0, 2.0, num=50)\ny1 = np.cos(2 * np.pi * x1) * np.exp(-x1)\ny2 = np.cos(2 * np.pi * x2)\n\nfig1 = plt.figure(figsize=(5, 4))\nplt.plot(x1, y1)\nplt.xlim(0, 6)\nplt.ylim(-1, 1)\n\n\n\n\n\n\n\nThen, we can save the figure in various formats:\n\nfig1.savefig(\"ma_figure_pas_belle.png\", format='png', dpi=90)\nfig1.savefig(\"ma_figure_plus_belle.svg\",format='svg', dpi=90)\n\nNow that the images have been saved, we can visualize the difference between the PNG and SVG formats.\nPNG (zoom on hover):\n\n    \n\nSVG (zoom on hover):\n\n    \n\n\n\n\n\n\n\nNote\n\n\n\nSome additional effects to produce the above zoom-on-hover effect can be found here: https://www.notuxedo.com/effet-de-zoom-image-css/\n\n\nReferences:\n\nIntroduction to geopandas\nCourse on images/slides by Joseph Salmon\nOfficial SciPy web page\nSciPy User Guide\nScipy lectures\nThe SciPy source code",
    "crumbs": [
      "Scientific Python",
      "SciPy"
    ]
  }
]